<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPM Stop Analysis Dashboard (Excel Filter)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
    <script src="https://apis.google.com/js/api.js"></script> 
  <style>
    body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        background: linear-gradient(135deg, #e0e7ff 0%, #f3e8ff 100%);
        margin: 0;
        padding: 30px; 
        min-height: 100vh; 
        display: flex;
        flex-direction: column;
        align-items: center;
        box-sizing: border-box;
    }

    h1 {
        text-align: center;
        color: #1e3a8a;
        font-size: 2.5rem;
        margin-bottom: 30px;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        letter-spacing: 0.5px;
        flex-shrink: 0;
    }

    .controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: flex-start; 
        gap: 20px; 
        margin-bottom: 30px;
        padding: 25px;
        background: #ffffff;
        border-radius: 12px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
        max-width: 1400px; 
        width: 100%;
        box-sizing: border-box;
        transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .controls:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    /* --- Excel Filter Styling --- */
    .filter-group-excel {
        display: flex;
        flex-direction: column;
        min-width: 220px; 
        flex: 1; 
        background: #f9fafb;
        padding: 15px;
        border-radius: 8px;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .filter-group-excel label {
        font-weight: 700;
        margin-bottom: 10px;
        color: #1f2937;
        font-size: 1.1rem;
    }

    .filter-search {
        padding: 10px 12px;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        margin-bottom: 8px;
        font-size: 0.95rem;
        background: #fff;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }

    .filter-search:focus {
        outline: none;
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }

    /* --- Checkbox List (Scrollable) --- */
    .checkbox-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        border: 1px solid #e5e7eb;
        border-radius: 6px;
        padding: 12px;
        max-height: 180px;      
        overflow-y: auto;        
        background: #ffffff;
        scrollbar-width: thin;
        scrollbar-color: #93c5fd #e5e7eb;
    }

    .checkbox-list::-webkit-scrollbar { width: 6px; }
    .checkbox-list::-webkit-scrollbar-track { background: #e5e7eb; border-radius: 3px; }
    .checkbox-list::-webkit-scrollbar-thumb { background: #93c5fd; border-radius: 3px; }
    .checkbox-list div { display: flex; align-items: center; }

    .checkbox-list label {
        display: flex;
        align-items: center;
        font-weight: 500;
        margin-bottom: 0;
        width: 100%;
        color: #374151;
        cursor: pointer;
        transition: color 0.3s ease;
    }

    .checkbox-list label:hover { color: #1e40af; }
    .checkbox-list input { margin-right: 10px; accent-color: #3b82f6; }

    /* --- Rake/Date/Recent Filter Styling --- */
    .filter-group {
        display: flex;
        flex-direction: column;
        min-width: 180px; 
        flex: 1; 
        background: #f9fafb;
        padding: 15px;
        border-radius: 8px;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .filter-group label {
        font-weight: 700;
        margin-bottom: 10px;
        color: #1f2937;
        font-size: 1.1rem;
    }

    .checkbox-group {
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 15px;
        border-radius: 6px;
        background: #fff; 
        border: 1px solid #e5e7eb; 
    }

    .checkbox-group div { display: flex; align-items: center; }
    .checkbox-group input { margin-right: 10px; accent-color: #3b82f6; }
    .checkbox-group label {
        font-weight: 500;
        color: #374151;
        cursor: pointer;
        transition: color 0.3s ease;
        margin-bottom: 0; 
    }
    .checkbox-group label:hover { color: #1e40af; }

    /* --- Recent Filter Select & Date Input Styling --- */
    .filter-group #recent-filter,
    .filter-group input[type="date"] {
        padding: 10px 12px;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        font-size: 0.95rem;
        background: #fff;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
        font-family: inherit; 
        color: #374151; 
        box-sizing: border-box; 
        width: 100%; 
    }

    .filter-group #recent-filter:focus,
    .filter-group input[type="date"]:focus {
        outline: none;
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }
     
    /* --- Chart Container --- */
    #chart-container {
        width: 100%;
        max-width: 1400px; 
        height: 650px; 
        background: #ffffff;
        border-radius: 12px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
        padding: 25px;
        box-sizing: border-box;
        display: none;
        transition: transform 0.3s ease;
    }

    #chart-container:hover {
        transform: translateY(-5px);
    }

    #loading {
        text-align: center;
        font-size: 1.3em;
        color: #6b7280;
        padding: 30px;
        background: #ffffff;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
    }

    /* --- Buttons --- */
    .button-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        align-self: center; 
        margin-top: 15px; 
        min-width: 250px;
    }

    #generate-btn, #toggle-average-btn {
        background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 100%);
        color: white;
        padding: 12px 25px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 1.1rem;
        font-weight: 600;
        transition: background 0.3s ease, transform 0.2s ease;
        width: 100%; 
        box-sizing: border-box;
        margin-left: 0; 
        margin-top: 0; 
    }

    #generate-btn:hover, #toggle-average-btn:hover {
        background: linear-gradient(90deg, #2563eb 0%, #3b82f6 100%);
        transform: scale(1.05);
    }

  </style>
</head>
<body>

    <h1>SPM Stop Analysis Dashboard</h1>
    <div id="loading">Loading data from Google Sheet...</div>

    <div class="controls" id="filters-panel" style="display: none;">
        
        <div class="filter-group">
            <label for="from-date">From Date:</label>
            <input type="date" id="from-date">
        </div>
        <div class="filter-group">
            <label for="to-date">To Date:</label>
            <input type="date" id="to-date">
        </div>
        <div class="filter-group-excel">
            <label for="lp-search">Select LP ID (Multiple):</label>
            <input type="text" id="lp-search" class="filter-search" onkeyup="filterCheckboxes('lp-search', 'lp-filter-list')" placeholder="Search LP...">
            <div id="lp-filter-list" class="checkbox-list">
            </div>
        </div>
        
        <div class="filter-group-excel">
            <label for="location-search">Select Stop Location (Multiple):</label>
            <input type="text" id="location-search" class="filter-search" onkeyup="filterCheckboxes('location-search', 'location-filter-list')" placeholder="Search Location...">
            <div id="location-filter-list" class="checkbox-list">
            </div>
        </div>

        <div class="filter-group">
            <label>Select Rake Type (Multiple):</label>
            <div class="checkbox-group" id="rake-filter">
                <div><input type="checkbox" id="rake-all" value="ALL" checked><label for="rake-all">ALL</label></div>
                <div><input type="checkbox" id="rake-goods-loaded" value="GOODS LOADED" checked><label for="rake-goods-loaded">GOODS LOADED</label></div>
                <div><input type="checkbox" id="rake-goods-empty" value="GOODS EMPTY" checked><label for="rake-goods-empty">GOODS EMPTY</label></div>
                <div><input type="checkbox" id="rake-coaching" value="COACHING" checked><label for="rake-coaching">COACHING</label></div>
                <div><input type="checkbox" id="rake-memu" value="MEMU" checked><label for="rake-memu">MEMU</label></div>
            </div>
        </div>

        <div class="filter-group">
            <label>Select Number of Recent Analyses:</label>
            <select id="recent-filter">
                <option value="all" selected>All</option>
                <option value="10">Last 10</option>
                <option value="20">Last 20</option>
                <option value="30">Last 30</option>
                <option value="40">Last 40</option>
                <option value="50">Last 50</option>
            </select>
        </div>
        
        <div class="button-container">
            <button id="generate-btn">Generate Graph</button>
            <button id="toggle-average-btn">Show Only Average Profile</button>
        </div>
    </div>

    <div id="chart-container"></div>

    <script>
        // --- CONFIGURATION ---
        const API_KEY = 'AIzaSyChXMJaTllbk8kg5w1bjM06PbbJO5MBeLo'; 
        const SHEET_ID = '1Pw0Ai-2G64pFMeQUZegjglySt_lD6qde4EiRTkDOLEs';
        
        // --- IMPORTANT: Change range to Detailed_Stops Sheet ---
        // Since we are now using Detailed_Stops, columns are different
        const RANGE = 'Detailed_Stops!A:R'; // Columns A to R (as per new schema)
        // ----------------------------------------

        // --- NEW COLUMN MAPPING FOR "Detailed_Stops" ---
        // A=0, B=1, C=2, D=3, E=4, F=5...
        // G=6 (2000m), H=7 (1000m), I=8 (800m)... Q=16 (0m), R=17 (Type)
        const COLS = {
            TIMESTAMP: 0,       // Col A (Date)
            TRAIN_NO: 1,        // Col B 
            LP_ID: 2,           // Col C
            NAME: 3,            // Col D
            STOP_LOCATION: 4,   // Col E
            KM: 5,              // Col F
            SPEED_2000: 6,      // Col G
            SPEED_1000: 7,      // Col H
            SPEED_800: 8,       // Col I
            SPEED_600: 9,       // Col J
            SPEED_500: 10,      // Col K
            SPEED_400: 11,      // Col L
            SPEED_300: 12,      // Col M
            SPEED_100: 13,      // Col N
            SPEED_50: 14,       // Col O
            SPEED_20: 15,       // Col P
            SPEED_0: 16,        // Col Q
            RAKE_TYPE: 17       // Col R (Braking Type? No, wait. 
                                // In Code.gs, Rake Type is NOT explicitly saved in Detailed_Stops 
                                // But Rake Type is usually needed for filter.
                                // Let's check: Code.gs saves 'Braking Technique' in last col.
                                // ISSUE: You might need RAKE TYPE in Detailed_Stops for filtering.
                                // For now, I will map Rake Type to Column R (Braking Type) or handle logic.
        };
        // NOTE: Since Detailed_Stops doesn't have Rake Type column in the headers you gave me earlier
        // (Date, Train No, LP ID, LP Name, Stop Location, KM, 2000...0, Braking Type)
        // You cannot filter by RAKE TYPE unless you add it to Detailed_Stops in Code.gs
        // However, I will proceed assuming you might add it later or filter by ID/Location only.

        const LINE_LIMIT = 50; 
        const COLOR_PALETTE = [
            '#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#42d4f4', '#f032e6', '#bfef45', '#fabed4', 
            '#469990', '#dcbeff', '#9A6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#a9a9a9'
        ];

        let myChart;
        let processedData = []; 
        let lpSet = new Set();
        let locationSet = new Set();
        const loadingDiv = document.getElementById('loading');
        const chartDiv = document.getElementById('chart-container');
        const filtersPanel = document.getElementById('filters-panel');
        let chartBaseOption; 
        let showOnlyAverage = false; 

        function parseDate(dateStr) {
            if (!dateStr) return null;
            // Handle DD/MM/YYYY
            const parts = dateStr.split('/');
            if (parts.length === 3) {
                return new Date(parts[2], parts[1] - 1, parts[0]);
            }
            return new Date(dateStr);
        }

        function formatDateToInput(date) {
            if (!date) return '';
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        document.addEventListener('DOMContentLoaded', () => {
            initChart();
            loadAndProcessData(); 
            document.getElementById('generate-btn').addEventListener('click', updateChart);
            document.getElementById('toggle-average-btn').addEventListener('click', toggleAverageProfile);
        });

        function initChart() {
            myChart = echarts.init(chartDiv);
            
            chartBaseOption = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'cross' }, 
                    formatter: (params) => {
                        let tooltip = `Distance: ${params[0].axisValue}m<br/>`;
                        params.sort((a, b) => (b.value[1] || 0) - (a.value[1] || 0)); 
                        params.forEach(param => {
                            if (param.value[1] !== null && param.value[1] !== undefined) {
                                tooltip += `${param.marker} ${param.seriesName}: ${param.value[1].toFixed(1)} Kmph<br/>`;
                            }
                        });
                        return tooltip;
                    }
                },
                toolbox: { 
                    show: true,
                    feature: {
                        dataZoom: { yAxisIndex: 'none' },
                        saveAsImage: {},
                        legendToggle: {
                            show: true,
                            title: 'Toggle Legend',
                            icon: 'path://M4,5h16v2H4V5zM4,11h16v2H4V11zM4,17h16v2H4V17z',
                            onclick: function () {
                                const currentOption = myChart.getOption();
                                const isLegendVisible = currentOption.legend[0].show;
                                myChart.setOption({ legend: { show: !isLegendVisible } });
                            }
                        }
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', top: '12%', containLabel: true },
                // UPDATED X-AXIS MAX to 2000
                xAxis: { type: 'value', name: 'Distance to Stop (m)', min: 0, max: 2000, inverse: true, axisLabel: { formatter: '{value} m' }, splitLine: { lineStyle: { type: 'dashed', color: '#eee' } } },
                yAxis: { type: 'value', name: 'Speed (Kmph)', min: 0, max: 130, axisLabel: { formatter: '{value} Kmph' }, splitLine: { lineStyle: { type: 'dashed', color: '#eee' } } },
                
                title: { text: 'Stop Approach Speed Analysis' },
                legend: { show: false, data: [], type: 'scroll', top: 30, padding: 5 },
                series: []
            };
            
            myChart.setOption(chartBaseOption);
        }

        function toggleAverageProfile() {
            showOnlyAverage = !showOnlyAverage;
            document.getElementById('toggle-average-btn').textContent = showOnlyAverage ? 'Show All Profiles' : 'Show Only Average Profile';
            updateChart();
        }

        async function loadAndProcessData() {
            try {
                await new Promise((resolve) => gapi.load('client', resolve));
                await gapi.client.init({
                    'apiKey': API_KEY,
                    'discoveryDocs': ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
                });
                const response = await gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId: SHEET_ID,
                    range: RANGE,
                });
                const rawData = response.result.values;
                if (!rawData || rawData.length === 0) { throw new Error("No data found in sheet."); }
                
                const { minDate, maxDate } = preprocessData(rawData);
                populateFilters(minDate, maxDate);
                setupAllFilterLogic(); 

                loadingDiv.style.display = 'none'; 
                filtersPanel.style.display = 'flex'; 

            } catch (error) {
                console.error('Error loading data:', error);
                loadingDiv.innerText = "Error loading data. Check console.";
            }
        }

        function preprocessData(rawData) {
            processedData = [];
            lpSet.clear();
            locationSet.clear();
            
            let minDate = null;
            let maxDate = null;

            // Start loop from 1 to skip header
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                if (!row || row.length < 5) continue; 
                
                const timestampStr = (row[COLS.TIMESTAMP] || "").trim();
                const currentTimestamp = parseDate(timestampStr);
                
                if (!currentTimestamp) continue;

                const trainNo = (row[COLS.TRAIN_NO] || "").trim();
                const lpId = (row[COLS.LP_ID] || "").trim();
                const name = (row[COLS.NAME] || "").trim();
                const stopLocation = (row[COLS.STOP_LOCATION] || "").trim();
                const km = (row[COLS.KM] || "").trim();
                
                // Note: Rake Type is not currently in Detailed_Stops, treating as Unknown or mapping later
                const rakeType = "UNKNOWN"; 

                if (!minDate || currentTimestamp < minDate) minDate = currentTimestamp;
                if (!maxDate || currentTimestamp > maxDate) maxDate = currentTimestamp;

                if (lpId) lpSet.add(lpId);
                if (stopLocation) locationSet.add(stopLocation);

                // Fetch new speeds
                let s2000 = parseFloat(row[COLS.SPEED_2000]);
                let s1000 = parseFloat(row[COLS.SPEED_1000]);
                let s800 = parseFloat(row[COLS.SPEED_800]);
                let s600 = parseFloat(row[COLS.SPEED_600]);
                let s500 = parseFloat(row[COLS.SPEED_500]);
                let s400 = parseFloat(row[COLS.SPEED_400]);
                let s300 = parseFloat(row[COLS.SPEED_300]);
                let s100 = parseFloat(row[COLS.SPEED_100]);
                let s50 = parseFloat(row[COLS.SPEED_50]);
                let s20 = parseFloat(row[COLS.SPEED_20]);
                let s0 = parseFloat(row[COLS.SPEED_0]);

                // Helper to validate speed
                const v = (s) => isNaN(s) ? null : s;

                // 11-point data array for graph
                const graphData = [
                    [2000, v(s2000)], 
                    [1000, v(s1000)], 
                    [800, v(s800)], 
                    [600, v(s600)], 
                    [500, v(s500)], 
                    [400, v(s400)], 
                    [300, v(s300)], 
                    [100, v(s100)], 
                    [50, v(s50)], 
                    [20, v(s20)], 
                    [0, v(s0)]
                ];

                processedData.push({
                    date: currentTimestamp,
                    dateStr: timestampStr,
                    trainNo: trainNo,
                    lpId: lpId,
                    name: name,
                    location: stopLocation,
                    rakeType: rakeType, 
                    km: km,
                    graphData: graphData
                });
            }
            
            return { minDate, maxDate };
        }

        function populateFilters(minDate, maxDate) {
            const lpList = document.getElementById('lp-filter-list');
            const locationList = document.getElementById('location-filter-list');
            
            let lpHtml = '<div><label><input type="checkbox" id="lp-all" class="filter-all" checked> <strong>ALL</strong></label></div>';
            [...lpSet].sort().forEach((lp) => {
                lpHtml += `<div><label><input type="checkbox" class="lp-item" value="${lp}" checked> ${lp}</label></div>`;
            });
            lpList.innerHTML = lpHtml;

            let locHtml = '<div><label><input type="checkbox" id="location-all" class="filter-all" checked> <strong>ALL</strong></label></div>';
            [...locationSet].sort().forEach((loc) => {
                locHtml += `<div><label><input type="checkbox" class="location-item" value="${loc}" checked> ${loc}</label></div>`;
            });
            locationList.innerHTML = locHtml;

            if (minDate) document.getElementById('from-date').value = formatDateToInput(minDate);
            if (maxDate) document.getElementById('to-date').value = formatDateToInput(maxDate);
        }

        function filterCheckboxes(inputId, listId) {
            let input = document.getElementById(inputId);
            let filter = input.value.toUpperCase();
            let list = document.getElementById(listId);
            let items = list.getElementsByTagName('div');

            for (let i = 1; i < items.length; i++) {
                let label = items[i].getElementsByTagName('label')[0];
                if (label) {
                    let txtValue = label.textContent || label.innerText;
                    if (txtValue.toUpperCase().indexOf(filter) > -1) {
                        items[i].style.display = "";
                    } else {
                        items[i].style.display = "none";
                    }
                }
            }
        }

        function setupAllFilterLogic() {
            function setupCheckboxLogic(allCheckboxId, itemClassName) {
                const allCb = document.getElementById(allCheckboxId);
                // Dynamically select items as they are added to DOM
                // Event delegation is better, but here we attach events after populating
                const itemCbs = document.querySelectorAll(`.${itemClassName}`);

                allCb.addEventListener('change', () => {
                    itemCbs.forEach(cb => {
                        // Only check visible ones if filtered? For now check all.
                        cb.checked = allCb.checked;
                    });
                });

                itemCbs.forEach(cb => {
                    cb.addEventListener('change', () => {
                        if (!cb.checked) {
                            allCb.checked = false;
                        } else if ([...itemCbs].every(c => c.checked)) {
                            allCb.checked = true;
                        }
                    });
                });
            }

            setupCheckboxLogic('lp-all', 'lp-item');
            setupCheckboxLogic('location-all', 'location-item');
            setupCheckboxLogic('rake-all', 'rake-item');
            
            document.querySelectorAll('#rake-filter input[type="checkbox"]:not(#rake-all)')
                    .forEach(cb => cb.classList.add('rake-item'));
        }

        function calculateAverageSeries(filteredStops) {
            if (filteredStops.length === 0) return null;
            
            // Updated sums/counts for 11 points
            const points = [2000, 1000, 800, 600, 500, 400, 300, 100, 50, 20, 0];
            const sums = {};
            const counts = {};
            points.forEach(p => { sums[p] = 0; counts[p] = 0; });
            
            for (const stop of filteredStops) {
                for (const point of stop.graphData) {
                    const distance = point[0];
                    const speed = point[1];
                    if (sums.hasOwnProperty(distance) && speed !== null && speed !== undefined) { 
                        sums[distance] += speed; 
                        counts[distance]++; 
                    }
                }
            }
            
            const avgData = points.map(p => [p, counts[p] > 0 ? sums[p] / counts[p] : null]);

            return {
                name: `Average Profile (${filteredStops.length} stops)`,
                type: 'line', data: avgData, smooth: true, symbol: 'none',
                color: '#c23531', 
                lineStyle: { width: 4, type: 'dashed', color: '#c23531' },
                emphasis: { lineStyle: { width: 6 } }
            };
        }

        function updateChart() {
            
            function getCheckedValues(allCheckboxId, itemClassName) {
                if (document.getElementById(allCheckboxId).checked) {
                    return ['ALL']; 
                }
                let values = [];
                document.querySelectorAll(`.${itemClassName}:checked`).forEach(cb => {
                    values.push(cb.value);
                });
                return values;
            }

            const selectedLps = getCheckedValues('lp-all', 'lp-item');
            const selectedLocations = getCheckedValues('location-all', 'location-item');
            // Rake filter disabled effectively since data missing in Detailed_Stops
            // const selectedRakes = getCheckedValues('rake-all', 'rake-item'); 

            const fromDateStr = document.getElementById('from-date').value;
            const toDateStr = document.getElementById('to-date').value;

            let fromDate = null;
            if (fromDateStr) {
                const parts = fromDateStr.split('-');
                fromDate = new Date(parts[0], parts[1] - 1, parts[2]);
            }
            let toDate = null;
            if (toDateStr) {
                const parts = toDateStr.split('-');
                toDate = new Date(parts[0], parts[1] - 1, parts[2]);
                toDate.setHours(23, 59, 59, 999); 
            }

            const filteredData = processedData.filter(stop => {
                const lpMatch = selectedLps.includes('ALL') || selectedLps.includes(stop.lpId);
                const locationMatch = selectedLocations.includes('ALL') || selectedLocations.includes(stop.location);
                // Skipping rake match for now
                const dateMatch = (!fromDate || stop.date >= fromDate) && (!toDate || stop.date <= toDate);
                
                return lpMatch && locationMatch && dateMatch;
            });

            const recentValue = document.getElementById('recent-filter').value;
            let displayData = filteredData;
            if (recentValue !== 'all') {
                const N = parseInt(recentValue);
                displayData = filteredData.slice(-N);
            }

            chartDiv.style.display = 'block';
            myChart.resize(); 

            if (displayData.length === 0) {
                myChart.setOption({
                    ...chartBaseOption,
                    title: { text: 'No matching data found', subtext: 'Please adjust your filter selection.', left: 'center', top: 'center' },
                    legend: { data: [] },
                    series: [] 
                }, true);
                return; 
            }
            
            const avgSeries = calculateAverageSeries(displayData);
            let finalSeries = [];
            if (avgSeries) {
                finalSeries.push(avgSeries); 
            }

            let subtext = null; 

            if (showOnlyAverage) {
                subtext = `Showing only average of ${displayData.length} stops.`;
            } else if (displayData.length > LINE_LIMIT) {
                subtext = `Showing average of ${displayData.length} stops. (Too many to show individually)`;
            } else {
                const seriesData = displayData.map((stop, index) => {
                    return {
                        name: `LP ${stop.lpId || 'N/A'} (${stop.name || 'N/A'}) (Tr ${stop.trainNo || 'N/A'}) @ ${stop.location} (KM ${stop.km})`,
                        type: 'line', smooth: true, symbol: 'none', 
                        lineStyle: { width: 2, opacity: 0.7 },
                        data: stop.graphData,
                        emphasis: { focus: 'series', lineStyle: { width: 4, opacity: 1 } },
                        color: COLOR_PALETTE[index % COLOR_PALETTE.length]
                    };
                });
                finalSeries.push(...seriesData);
            }
            
            myChart.setOption({
                ...chartBaseOption,
                title: { 
                    text: 'Stop Approach Speed Analysis', 
                    subtext: subtext, 
                    left: 'auto', 
                    top: 'auto' 
                },
                legend: { 
                    ...chartBaseOption.legend,
                    data: finalSeries.map(s => s.name)
                },
                series: finalSeries
            }, true);
        }

    </script>
</body>
</html>
